# Sorting Algorithms Project

## Overview
This project consists of implementations of various sorting algorithms, as covered in our lectures. The primary aim was to gain hands-on experience by coding these algorithms from scratch, thereby deepening my understanding of their mechanics, efficiencies, and real-world applications.

## Algorithms Implemented
##### Homework 1
- **Selection Sort**: A simple comparison-based algorithm with an average and worst-case complexity of O(n²), where n is the number of items sorted.
- **Insertion Sort**: Efficient for small data sets with an average and worst-case complexity also of O(n²).
- **Merge Sort**: An efficient, stable, and comparison-based algorithm with a worst-case complexity of O(n log n).
- **Quick Sort**: An efficient sorting algorithm, serving as a systematic method for placing the elements of an array in order. It has an average and worst-case complexity of O(n log n) and O(n²), respectively.

##### Homework 2
- **Count Sort**: A non-comparison-based sorting algorithm, ideal for sorting integers within a specific range, operating with linear time complexity under certain conditions.
- **Radix Sort**: Extends the idea of Count Sort by sorting digits of numbers one at a time, ensuring a stable sort with complexity O(nk) for n numbers and k digit positions.

##### Homework 3
- **Binary Search: Lower-Bound**: Identifies the first position where a given value could be inserted without changing the order.
- **Binary Search: Upper-Bound**: Finds the last position a value could be inserted orderly, highlighting the efficiency of binary search in sorted arrays.

##### Homework 4
- **Randomized Partition**: A pivot selection technique for Quick Sort, improving the average-case time complexity by randomizing the pivot choice.
- **Randomized Selection**: An algorithm to find the ith smallest element in an array efficiently, utilizing the randomized partition strategy.

##### Homework 5
- **Depth-First Search (DFS)**: An algorithm for traversing or searching tree or graph data structures, starting at the root and exploring as far as possible along each branch before backtracking.
- **Breadth-First Search (BFS)**: Explores the neighbor nodes 

## Development Environment
The development was carried out using C++ with Visual Studio Code, ensuring a consistent and efficient coding experience.

## Key Learnings
- **Algorithm Efficiency**: Gained insights into how different algorithms perform under various conditions, emphasizing the importance of algorithmic efficiency in software development.
- **Problem-Solving Skills**: Enhanced my problem-solving skills by implementing and debugging the sorting algorithms.
- **Practical Application of Theoretical Concepts**: Applied theoretical knowledge from lectures to practical coding challenges, reinforcing my understanding of sorting algorithms.

## Challenges Faced
- **Debugging Complex Algorithms**: Debugging the merge and quick sort algorithms was particularly challenging, requiring a deep understanding of recursion and partitioning strategies.
- **Optimizing for Efficiency**: Strived to optimize each algorithm's implementation for better performance, which was a valuable learning experience in considering time and space complexities.

## Conclusion
These projects were instrumental in solidifying my understanding of algorithms, their implementations, and their implications in real-world applications. It was a valuable exercise in applying theoretical knowledge to practical coding tasks, thereby enhancing my technical skills and problem-solving abilities.

## How to Run
Refer to the README file within each homework folder.
